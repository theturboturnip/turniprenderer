#pragma once

#include "hierarchy.h"

namespace TurnipRenderer {
	template<class NodeContent>
	void Hierarchy<NodeContent>::Node::updateCachedEnd(bool updateParent){
		if (children.size() == 0){
			cachedEndMinus1 = me;
		}else{
			cachedEndMinus1 = children[children.size() - 1]->cachedEndMinus1;
		}
		if (parent != me) parent->updateCachedEnd(); // Tail recursion, won't add to the stack
	}

	template<class NodeContent>
	inline size_t Hierarchy<NodeContent>::getRealSiblingIndex(OrderedIterator newParent, int relSiblingIndex){
		const int newSiblingCount = static_cast<int>(newParent->children.size());
		if (newSiblingCount == 0) return 0;
			
		if (relSiblingIndex > newSiblingCount) relSiblingIndex %= newSiblingCount;
		while (relSiblingIndex < 0) relSiblingIndex += newSiblingCount + 1;
			
		return static_cast<size_t>(relSiblingIndex);
	}
		
	template<class NodeContent>
	inline typename Hierarchy<NodeContent>::OrderedIterator Hierarchy<NodeContent>::nodePositionFromParentAndSiblingIndex(OrderedIterator parent, size_t siblingIndex){
		if (siblingIndex > 0)
			return parent->children[siblingIndex - 1]->heirarchyEnd();
		return parent.plusOne();
	}
		
	// Utility function to update a node when a sibling of a given index is changed (deleted or inserted)
	template<class NodeContent>
	inline void Hierarchy<NodeContent>::updateNodeParent(OrderedIterator parent, size_t siblingIndex){
		auto& siblings = parent->children;
		if (siblingIndex >= siblings.size() - 1)
			parent->updateCachedEnd(); // This will update the parent's parent's end, and continue up the stack
		// Update new siblings that have changed
		for (size_t i = siblingIndex; i < siblings.size(); i++) {
			siblings[i]->siblingIndex = i;
		}
	}
		
	// Utility function to use when reparenting nodes
	template<class NodeContent>
	inline void Hierarchy<NodeContent>::moveNodeAndChildren(OrderedIterator toMove, OrderedIterator newLocation){
		if (newLocation == toMove->heirarchyBegin()) return;
		orderedNodes.splice(newLocation,
							orderedNodes, // A std::list splicing itself is defined to work
							toMove->heirarchyBegin(), toMove->heirarchyEnd());
	}

	template<class NodeContent>
	template<class... Args>
	typename Hierarchy<NodeContent>::Node& Hierarchy<NodeContent>::addNode(Node& newParentRef, int relSiblingIndex, Args&&... args){
		OrderedIterator newParent = newParentRef.me;
		size_t newSiblingIndex = getRealSiblingIndex(newParent, relSiblingIndex);

		OrderedIterator addedNode = orderedNodes.insert(nodePositionFromParentAndSiblingIndex(newParent, newSiblingIndex), nullptr);
		std::unique_ptr<Node> nodeStoragePtr = std::make_unique<Node>(
			addedNode, newParent, newSiblingIndex,
			std::forward<Args>(args)... // Arguments for NodeContent constructor
			);
		*addedNode = nodeStoragePtr.get();
		auto& newSiblings = newParent->children;
		newSiblings.insert(newSiblings.begin() + newSiblingIndex, addedNode->me);
		updateNodeParent(addedNode->parent, addedNode->siblingIndex);

		addedNode->initialize();
		
		unorderedNodes.push_back(std::move(nodeStoragePtr));
		return addedNode->me;
	}
	template<class NodeContent>
	void Hierarchy<NodeContent>::unparentNode(Node& node, int relSiblingIndex){
		reparentNode(node, root, relSiblingIndex);
	}
	template<class NodeContent>
	void Hierarchy<NodeContent>::reparentNode(Node& node, Node& newParentNode, int relSiblingIndex){
		if (node.isRoot()) return;
			
		auto& newParent = newParentNode.me;
		auto newSiblingIndex = getRealSiblingIndex(newParent, relSiblingIndex);

		// Update old stuff
		{
			// Update old parent
			auto& oldSiblings = node.parent->children;
			oldSiblings.erase(oldSiblings.begin() + node.siblingIndex);
			updateNodeParent(node.parent, node.siblingIndex);
		}
				
		// Update the node itself
		moveNodeAndChildren(node.me, nodePositionFromParentAndSiblingIndex(newParent, newSiblingIndex));
		node.parent = newParent;
		node.siblingIndex = newSiblingIndex;

		// Update new parent
		{
			auto& newSiblings = newParent->children;
			newSiblings.insert(newSiblings.begin() + newSiblingIndex, node.me);
			updateNodeParent(node.parent, node.siblingIndex);
		}
	}
}
