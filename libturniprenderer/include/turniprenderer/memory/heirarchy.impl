#pragma once

#include "heirarchy.h"

namespace TurnipRenderer {
	template<class Node>
	void Heirarchy<Node>::NodeData::updateCachedEnd(bool updateParent){
		if (children.size() == 0){
			cachedEndMinus1 = me;
		}else{
			cachedEndMinus1 = children[children.size() - 1]->nodeData.cachedEndMinus1;
		}
		if ((Node*)me != heirarchy->root.get()) parent->nodeData.updateCachedEnd(); // Tail recursion, won't add to the stack
	}
	
	template<class Node>
	Heirarchy<Node>::Heirarchy(std::unique_ptr<Node> newRoot) : root(std::move(newRoot)) {			
		heirarchy.push_back(root.get());
		root->nodeData.heirarchy = this;
		root->nodeData.me = heirarchy.begin();
		// This is meant to be meaningless data
		root->nodeData.parent = root->nodeData.me;
		root->nodeData.siblingIndex = 0;
		root->nodeData.updateCachedEnd(false); // Don't update the parent
		root->initialize();
	}

	template<class Node>
	typename Heirarchy<Node>::NodeRef Heirarchy<Node>::addNode(std::unique_ptr<Node> nodeStoragePtr, Node* newParentPtr, int relSiblingIndex){
		NodeRef newParent = (newParentPtr == nullptr) ? root->nodeData.me : newParentPtr->nodeData.me;
		size_t newSiblingIndex = getRealSiblingIndex(newParent, relSiblingIndex);

		NodeRef addedNode = heirarchy.insert(nodePositionFromParentAndSiblingIndex(newParent, newSiblingIndex) + 1, nodeStoragePtr.get());
		auto& nodeData = addedNode->nodeData;
		nodeData.heirarchy = this;
		nodeData.me = addedNode;
		nodeData.parent = newParent;
		nodeData.siblingIndex = newSiblingIndex;
		nodeData.updateCachedEnd(false); // Don't update the parent, it will be done in updateNodeParent if necessary
		auto& newSiblings = newParent->nodeData.children;
		newSiblings.insert(newSiblings.begin() + newSiblingIndex, nodeData.me);
		updateNodeParent(nodeData.parent, nodeData.siblingIndex);

		addedNode->initialize();
		
		storage.push_back(std::move(nodeStoragePtr));
		return nodeData.me;
	}
	template<class Node>
	void Heirarchy<Node>::unparentNode(Node& node, int relSiblingIndex){
		reparentNode(node, *root, relSiblingIndex);
	}
	template<class Node>
	void Heirarchy<Node>::reparentNode(Node& node, Node& newParentNode, int relSiblingIndex){
		if (&node == root.get()) return;
			
		auto& nodeData = node.nodeData;
		auto& newParent = newParentNode.nodeData.me;
		auto newSiblingIndex = getRealSiblingIndex(newParent, relSiblingIndex);

		// Update old stuff
		{
			// Update old parent
			auto& oldSiblings = nodeData.parent->nodeData.children;
			oldSiblings.erase(oldSiblings.begin() + nodeData.siblingIndex);
			updateNodeParent(nodeData.parent, nodeData.siblingIndex);
		}
				
		// Update the node itself
		moveNodeAndChildren(nodeData.me, nodePositionFromParentAndSiblingIndex(newParent, newSiblingIndex));
		nodeData.parent = newParent;
		nodeData.siblingIndex = newSiblingIndex;

		// Update new parent
		{
			auto& newSiblings = newParent->nodeData.children;
			newSiblings.insert(newSiblings.begin() + newSiblingIndex, nodeData.me);
			updateNodeParent(nodeData.parent, nodeData.siblingIndex);
		}
	}
}
